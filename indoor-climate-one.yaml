esphome:
  name: indoor-climate-one
  includes:
    - co2tocolor.h

esp32:
  # TODO: board isn't quite right
  # https://github.com/platformio/platform-espressif32/pull/745
  board: featheresp32
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  services:
    - service: play_rtttl
      variables:
        song_str: string
      then:
        - rtttl.play:
            rtttl: !lambda 'return song_str;'
    - service: simulate_co2
      variables:
        simulated_co2: float
      then:
        - lambda: on_new_co2(simulated_co2, id(led_external), id(buzzer));

# Enable over the air updates
ota:

# Enable webserver for fun
web_server:
  port: 80

# Wifi connection
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true  # there is only one network around here, use that right away.
# (I disabled the default fallback access point)


# -------------------------
# Substitutions & Globals
# -------------------------

substitutions:
  recoverysong: Cantina:d=4, o=5, b=250:8a, 8p, 8d6, 8p, 8a, 8p, 8d6, 8p, 8a, 8d6, 8p, 8a, 8p, 8g#, a, 8a, 8g#, 8a, g, 8f#, 8g, 8f#, f., 8d., 16p, p., 8a, 8p, 8d6, 8p, 8a, 8p, 8d6, 8p, 8a, 8d6, 8p, 8a, 8p, 8g#, 8a, 8p, 8g, 8p, g., 8f#, 8g, 8p, 8c6, a#, a, g
  alarmsong: alarm:d=4,o=5,b=100:16e6,16e6,4p,16e6,16e6,4p,16e6,16e6,4p,16e6,16e6
# RR:d=4,o=5,b=200:8g,8a,8c6,8a,e6,8p,e6,8p,d6.,p,8p,8g,8a,8c6,8a,d6,8p,d6,8p,c6,8b,a.,8g,8a,8c6,8a,2c6,d6,b,a,g.,8p,g,2d6,2c6.,p,8g,8a,8c6,8a,e6,8p,e6,8p,d6.,p,8p,8g,8a,8c6,8a,2g6,b,c6.,8b,a,8g,8a,8c6,8a,2c6,d6,b,a,g.,8p,g,2d6,2c6
# zelda_woods:d=4,o=5,b=140:8f6,8a6,b6,8f6,8a6,b6,8f6,8a6,8b6,8e7,d7,8b6,8c7,8b6,8g6,2e6,8d6,8e6,8g6,2e6,8f6,8a6,b6,8f6,8a6,b6,8f6,8a6,8b6,8e7,d7,8b6,8c7,8e7,8b6,2g6,8b6,8g6,8d6,2e6
# MissionImp:d=16,o=6,b=95:32d,32d#,32d,32d#,32d,32d#,32d,32d#,32d,32d,32d#,32e,32f,32f#,32g,g,8p,g,8p,a#,p,c7,p,g,8p,g,8p,f,p,f#,p,g,8p,g,8p,a#,p,c7,p,g,8p,g,8p,f,p,f#,p,a#,g,2d,32p,a#,g,2c#,32p,a#,g,2c,a#5,8c,2p,32p,a#5,g5,2f#,32p,a#5,g5,2f,32p,a#5,g5,2e,d#,8d
# http://www.fodor.sk/Spectrum/rttl.htm
# https://www.end2endzone.com/how-to-convert-arduino-code-to-actual-rtttl-melodies-using-librtttl-and-anyrtttl/


globals:
  - id: silent_mode
    type: bool
    initial_value: 'false'

script:
  - id: gradient_demo
    then:
      - if:
          condition:
            lambda: 'return !id(silent_mode);'
          then:
            - globals.set:
                id: silent_mode
                value: 'true'
            - lambda: 'set_light_color_to_gradient(0.0, 100, id(led_external));'
            - delay: 0.3s
            - lambda: 'set_light_color_to_gradient(0.1, 100, id(led_external));'
            - delay: 0.3s
            - lambda: 'set_light_color_to_gradient(0.2, 100, id(led_external));'
            - delay: 0.3s
            - lambda: 'set_light_color_to_gradient(0.3, 100, id(led_external));'
            - delay: 0.3s
            - lambda: 'set_light_color_to_gradient(0.4, 100, id(led_external));'
            - delay: 0.3s
            - lambda: 'set_light_color_to_gradient(0.5, 100, id(led_external));'
            - delay: 0.3s
            - lambda: 'set_light_color_to_gradient(0.6, 100, id(led_external));'
            - delay: 0.3s
            - lambda: 'set_light_color_to_gradient(0.7, 100, id(led_external));'
            - delay: 0.3s
            - lambda: 'set_light_color_to_gradient(0.8, 100, id(led_external));'
            - delay: 0.3s
            - lambda: 'set_light_color_to_gradient(0.9, 100, id(led_external));'
            - delay: 0.3s
            - lambda: 'set_light_color_to_gradient(1.0, 100, id(led_external));'
            - globals.set:
                id: silent_mode
                value: 'false'

# -------------------------
# Components
# -------------------------

binary_sensor:
  - platform: gpio
    name: "Onboard Button"
    pin:
      number: GPIO27
      inverted: true
      mode:
        input: true
        pullup: true
    internal: true
    on_press:
      then:
      # - script.execute: gradient_demo
        - lambda: id(silent_mode) = !id(silent_mode);
        - if:
            condition:
              lambda: 'return id(silent_mode);'
            then:
              - light.turn_off: led_external
            else:
              - lambda: set_light_color_to_co2(id(co2).state, id(led_external));

i2c:
  sda: 21
  scl: 22
  scan: false  # seems redundant as we know exactly what's on the bus!

sensor:
  - platform: scd4x
    update_interval: 20s
    co2:
      name: "Room Sensor 1 - CO2"
      id: "co2"
      # discard first value (it's typically garbage)
      filters:
        - lambda: |-
            static bool first_run = true;
            if (first_run || x < 100.0) { // smaller than 100 is obviously garbage
              first_run = false;
              return {};
            } else {
              return std::min(x, 3000.0f); // if you blew on it I won't make it blow up!
            }
      on_value:
        then:
          - lambda: on_new_co2(x, id(led_external), id(buzzer));
    temperature:
      name: "Room Sensor 1 - Temperature"
      id: "temperature"
    humidity:
      name: "Room Sensor 1 - Humidity"
      id: "humidity"

output:
  - platform: ledc
    pin: GPIO25
    id: pin_buzzer

rtttl:
  id: buzzer
  output: pin_buzzer

status_led:
  pin: GPIO2   # yes it's a stripping pin yada yada -.-

light:
  - platform: neopixelbus 
    name: "Onboard RGB"
    id: "led_internal"
    variant: WS2812
    pin: GPIO5
    num_leds: 1
    type: GRB
    default_transition_length: 0s
    restore_mode: ALWAYS_OFF # not used right now, have experiments not leak into restart!
    internal: true

    # neopixelbus works SO MUCH better than fastled_clockless for this one!
    # fastled_clockless sometimes dropped colors/transitions
  - platform: neopixelbus
    name: "External RGB"
    id: "led_external"
    variant: WS2812
    pin: GPIO26
    num_leds: 1
    type: RGB
    default_transition_length: 8.0s
    restore_mode: ALWAYS_ON
    gamma_correct: 1.0  # turning off making the "co2 gradient" nicer. Otherwise it's hard to distinguish reds!
    internal: true
